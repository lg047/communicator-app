<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- ✅ critical for iPhone sizing + media queries -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <meta property="og:title" content="TotoType" />
  <meta property="og:description" content="A simple speech interface for fast communication." />
  <meta property="og:image" content="https://postimg.cc/F1sD5n4P" />
  <meta property="og:url" content="https://tototype.com" />
  <meta property="og:type" content="website" />
  <link rel="icon" href="/tototype_icon_new.png" type="image/png" />
  <title>TotoType</title>

  <style>
    html,body{margin:0;padding:0;width:100%;height:100%;overflow:hidden;background:#fff;font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;transition:background-color .3s,color .3s}
    body.dark-mode{color:#fff;background:#000} /* ✅ restore original dark mode behavior */
    body.dark-mode #editor{color:#fff}

    #editor{
      width:100%;
      height:calc(100% - 80px);
      font-size:6vw;
      line-height:1.2;
      white-space:pre-wrap;
      overflow-wrap:break-word;
      word-break:break-word;
      outline:none;
      padding:90px 200px;
      box-sizing:border-box;
      color:inherit
    }

    /* Desktop gear */
    #settingsBtn{
      position:fixed;top:20px;right:20px;
      background:none;border:none;
      font-size:4rem;cursor:pointer;color:#888;
      z-index:1003
    }

    /* Mobile top bar (Clear + Gear) */
    #mobileTopBar{
      position:fixed;
      top:12px;
      right:12px;
      display:none;
      gap:10px;
      z-index:1004;
      align-items:center;
    }

    .topBtn{
      border:none;
      background:rgba(255,255,255,.92);
      box-shadow:0 10px 22px rgba(0,0,0,.22);
      cursor:pointer;
      color:#111;
      -webkit-tap-highlight-color: transparent;
    }
    body.dark-mode .topBtn{
      background:rgba(0,0,0,.75);
      color:#fff;
    }

    /* overlay for mobile modal */
    #settingsOverlay{
      position:fixed;inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      z-index:1001
    }

    /* Settings menu (desktop default) */
    #settingsMenu{
      position:fixed;top:80px;right:20px;
      background:rgba(255,255,255,.95);
      border:1px solid #ccc;border-radius:8px;
      display:none;flex-direction:column;
      padding:12px;
      box-shadow:0 2px 8px rgba(0,0,0,.18);
      z-index:1002;width:260px
    }
    body.dark-mode #settingsMenu{background:rgba(0,0,0,.9);border-color:#444}

    .settings-item{display:flex;justify-content:space-between;align-items:center;margin:10px 0}
    .switch{position:relative;display:inline-block;width:50px;height:24px}
    .switch input{opacity:0;width:0;height:0}
    .slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#ccc;transition:.2s;border-radius:24px}
    .slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:#fff;transition:.2s;border-radius:50%}
    input:checked + .slider{background:#2196f3}
    input:checked + .slider:before{transform:translateX(26px)}
    .switch-label{font-size:.95rem;color:inherit}

    #doneBtn{
      margin-top:10px;width:100%;
      padding:8px;font-size:1rem;
      background:none;border:1px solid #888;border-radius:10px;
      cursor:pointer;color:inherit
    }

    /* ---------- Desktop footer: centered mode + zoom ---------- */
    #footerBar{
      position:fixed;
      left:50%;
      bottom:12px;
      transform:translateX(-50%);
      display:flex;
      align-items:center;
      gap:14px;
      padding:8px 12px;
      border-radius:10px;
      background:rgba(255,255,255,.65);
      color:#333;
      z-index:1000;
      user-select:none;
      pointer-events:none;
    }
    body.dark-mode #footerBar{
      background:rgba(0,0,0,.6);
      color:#ddd;
    }
    #modeLabel{
      font-size:.95rem;
      pointer-events:none;
      white-space:nowrap;
    }
    #zoomGroup{
      display:flex;
      gap:8px;
      pointer-events:auto;
    }

    /* ✅ darker button boxes so they look clickable */
    #zoomGroup button{
      font-size:1.1rem;
      padding:.38em .75em;
      border:none;
      border-radius:8px;
      background:rgba(210,210,210,.95);
      cursor:pointer;
      color:#222;
    }
    body.dark-mode #zoomGroup button{
      background:rgba(55,55,55,.85);
      color:#eee;
    }

    /* Keep old elements around for compatibility; hide on desktop now */
    #controls, #shortcuts { display:none; }

    #dog,#jpHead{position:fixed;bottom:0;height:240px;pointer-events:auto;cursor:pointer;transition:transform .05s linear,filter .1s}
    #jpHead{right:0;height:225px}
    #dog.pressed,#jpHead.pressed{filter:brightness(.8)}

    /* ---------- Mobile / iOS UI ---------- */
    @media (max-width: 900px), (pointer: coarse) {
      /* Use mobile top bar instead of desktop gear */
      #settingsBtn{display:none;}
      #mobileTopBar{
        display:flex;
        top:calc(14px + env(safe-area-inset-top));
        right:14px;
        gap:16px;
        justify-content:flex-end;
      }

      /* Clear + Gear sizes (kept) */
      #mobileClear{
        width:auto;
        padding:14px 18px;
        font-size:2.0rem;
        border-radius:22px;
      }
      #mobileGear{
        width:auto;
        padding:12px 14px;
        font-size:2.2rem;
        border-radius:999px;
      }

      /* Hide desktop footer on mobile */
      #footerBar{display:none !important;}

      /* Leave room for top bar */
      #editor{
        padding:140px 22px;
        height:100%;
      }

      /* Settings modal */
      #settingsMenu{
        left:16px;
        right:16px;
        top:50%;
        transform:translateY(-50%);
        width:auto;

        max-height:42vh;
        overflow:auto;

        border-radius:22px;
        padding:10px 10px 10px;
        box-shadow:0 16px 48px rgba(0,0,0,.32);
      }

      /* Hide images toggle on mobile (as before) */
      #imagesItem{display:none !important;}

      .settings-item{
        margin:0;
        padding:10px 4px;
      }

      .switch-label{
        font-size:1.65rem;
        line-height:1.15;
      }

      .switch{width:110px;height:56px}
      .slider{border-radius:56px}
      .slider:before{
        width:48px;height:48px;
        left:4px;bottom:4px;
      }
      input:checked + .slider:before{transform:translateX(50px)}

      #doneBtn{
        margin-top:12px;
        font-size:1.65rem;
        padding:12px 12px;
        border-radius:18px;
        border-width:2px;
      }
    }
  </style>
</head>

<body>
  <!-- Mobile top bar -->
  <div id="mobileTopBar">
    <button class="topBtn" id="mobileClear">Clear</button>
    <button class="topBtn" id="mobileGear" aria-label="Settings">⚙</button>
  </div>

  <!-- Desktop gear -->
  <button id="settingsBtn">⚙</button>

  <div id="settingsOverlay"></div>

  <div id="settingsMenu" aria-modal="true" role="dialog">
    <div class="settings-item" id="darkItem">
      <span class="switch-label">Dark Mode</span>
      <label class="switch"><input type="checkbox" id="darkSwitch"><span class="slider"></span></label>
    </div>

    <div class="settings-item" id="shareItem">
      <span class="switch-label">Share Mode</span>
      <label class="switch"><input type="checkbox" id="shareSwitch"><span class="slider"></span></label>
    </div>

    <div class="settings-item" id="viewerItem">
      <span class="switch-label">Viewer Mode</span>
      <label class="switch"><input type="checkbox" id="viewerSwitch"><span class="slider"></span></label>
    </div>

    <div class="settings-item" id="imagesItem">
      <span class="switch-label">Show Images</span>
      <label class="switch"><input type="checkbox" id="imagesSwitch" checked><span class="slider"></span></label>
    </div>

    <button id="doneBtn">Done</button>
  </div>

  <div id="editor" contenteditable="true" spellcheck="false"></div>

  <!-- Desktop footer -->
  <div id="footerBar">
    <div id="modeLabel">Mode: Solo</div>
    <div id="zoomGroup">
      <button id="zoomOut" aria-label="Zoom out">A-</button>
      <button id="zoomIn" aria-label="Zoom in">A+</button>
    </div>
  </div>

  <!-- Keep old elements hidden (compat) -->
  <div id="controls"><button id="zoomOutOld">A-</button><button id="zoomInOld">A+</button></div>
  <div id="shortcuts"></div>

  <!-- Media: DO NOT set src attributes here -->
  <img data-src="pipi_new1.png" loading="lazy" decoding="async" id="dog" alt="pipi image" style="display:none">
  <img data-src="jp.png" loading="lazy" decoding="async" id="jpHead" alt="jp image" style="display:none">
  <audio id="pipiSound" data-src="pipi.wav" preload="none"></audio>
  <audio id="jpSound" data-src="jp.wav" preload="none"></audio>

  <script>
    // ---------- DOM refs ----------
    const body=document.body;
    const editor=document.getElementById('editor');

    const settingsBtn=document.getElementById('settingsBtn');
    const settingsMenu=document.getElementById('settingsMenu');
    const settingsOverlay=document.getElementById('settingsOverlay');
    const doneBtn=document.getElementById('doneBtn');

    const mobileGear=document.getElementById('mobileGear');
    const mobileClear=document.getElementById('mobileClear');

    const darkSwitch=document.getElementById('darkSwitch');
    const imagesSwitch=document.getElementById('imagesSwitch');
    const shareSwitch=document.getElementById('shareSwitch');
    const viewerSwitch=document.getElementById('viewerSwitch');

    const zoomInBtn=document.getElementById('zoomIn');
    const zoomOutBtn=document.getElementById('zoomOut');
    const modeLabel=document.getElementById('modeLabel');

    const dog=document.getElementById('dog');
    const jpHead=document.getElementById('jpHead');
    const pipiAudio=document.getElementById('pipiSound');
    const jpAudio=document.getElementById('jpSound');

    // ---------- Mobile detection ----------
    const isMobile = (() => {
      const ua = navigator.userAgent || '';
      const uaMobile = /iPhone|iPad|iPod|Android/i.test(ua);
      const coarse = !!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
      return uaMobile || (coarse && window.innerWidth <= 900) || window.innerWidth <= 768;
    })();

    // ---------- Local-only storage (Solo mode) ----------
    const SOLO_KEY = 'tototype_solo_text';
    function loadSoloText(){ return localStorage.getItem(SOLO_KEY) ?? ''; }
    function saveSoloText(t){ localStorage.setItem(SOLO_KEY, t ?? ''); }

    // ---------- UI state ----------
    const DEFAULT_FONT_VW_DESKTOP = 6;
    const DEFAULT_FONT_VW_MOBILE  = 10;
    let defaultFontVW = isMobile ? DEFAULT_FONT_VW_MOBILE : DEFAULT_FONT_VW_DESKTOP;
    let fontSizeVW = defaultFontVW;

    function setFontSize(){ editor.style.fontSize = fontSizeVW+'vw'; }
    function adjustFontSizeToFit(){
      while(editor.scrollHeight > editor.clientHeight && fontSizeVW > 2){
        fontSizeVW = Math.max(fontSizeVW - 0.5, 2);
        setFontSize();
      }
    }

    function currentMode(){
      if (viewerSwitch.checked) return 'viewer';
      if (shareSwitch.checked) return 'share';
      return 'solo';
    }

    function refreshModeLabel(){
      const mode = currentMode();
      modeLabel.textContent = `Mode: ${mode[0].toUpperCase()+mode.slice(1)}`;
    }

    /* ✅ restore main pad background behavior via JS too */
    function updateBg(){
      body.style.backgroundColor = darkSwitch.checked ? '#000' : '#fff';
    }

    function refreshState(){
      editor.style.color = darkSwitch.checked ? '#fff' : '';
      updateBg();
      refreshModeLabel();
    }

    // ---------- Editor editability by mode ----------
    function applyEditorByMode(){
      const mode = currentMode();
      if (mode === 'viewer') {
        editor.blur();
        editor.setAttribute('contenteditable','false');
        editor.style.pointerEvents = 'auto';
      } else {
        editor.setAttribute('contenteditable','true');
        editor.style.pointerEvents = 'auto';
      }

      // Clear button visible only when NOT viewer
      if (mobileClear) {
        mobileClear.style.display = (mode === 'viewer') ? 'none' : '';
      }
    }

    // ---------- Media lazy-load (desktop only) ----------
    let mediaLoaded = false;
    function loadMediaIfNeeded(){
      if (mediaLoaded) return;
      mediaLoaded = true;

      if (dog && !dog.getAttribute('src')) dog.setAttribute('src', dog.dataset.src || '');
      if (jpHead && !jpHead.getAttribute('src')) jpHead.setAttribute('src', jpHead.dataset.src || '');

      if (pipiAudio && !pipiAudio.getAttribute('src')) pipiAudio.setAttribute('src', pipiAudio.dataset.src || '');
      if (jpAudio && !jpAudio.getAttribute('src')) jpAudio.setAttribute('src', jpAudio.dataset.src || '');
    }

    function toggleImages(show){
      if (isMobile) {
        dog.style.display = 'none';
        jpHead.style.display = 'none';
        [pipiAudio, jpAudio].forEach(a=>{ try{a.pause();a.currentTime=0;}catch{} });
        dog.style.transform = jpHead.style.transform = '';
        return;
      }

      if (show) loadMediaIfNeeded();

      const disp = show ? '' : 'none';
      dog.style.display = jpHead.style.display = disp;

      if(!show){
        [pipiAudio,jpAudio].forEach(a=>{ try{a.pause();a.currentTime=0;}catch{} });
        dog.style.transform = jpHead.style.transform = '';
      }
    }

    // ---------- Soundboard visuals (desktop only) ----------
    const AudioContext=window.AudioContext||window.webkitAudioContext;
    let audioCtx;
    function ensureCtx(){ if(!AudioContext) return null; if(!audioCtx) audioCtx = new AudioContext(); if(audioCtx.state==='suspended') audioCtx.resume(); return audioCtx; }
    function attachAnalyser(el){
      if(el.analyser || !ensureCtx() || !el.getAttribute('src')) return;
      const src = audioCtx.createMediaElementSource(el);
      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 256;
      src.connect(analyser);
      analyser.connect(audioCtx.destination);
      el.analyser = analyser;
    }
    function pulse(el,audio){
      attachAnalyser(audio);
      if(!audio.analyser) return;
      const data=new Uint8Array(audio.analyser.frequencyBinCount);
      function step(){
        if(audio.paused||audio.ended){ el.style.transform=''; return; }
        audio.analyser.getByteFrequencyData(data);
        let sum=0; for(let i=0;i<data.length;i++) sum+=data[i];
        const scale=1+(sum/data.length/255)*0.12;
        el.style.transform=`scale(${scale})`;
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }
    function addSoundEvents(el,audio){
      el.addEventListener('pointerdown',()=>{
        if (isMobile) return;
        if (!imagesSwitch.checked) return;
        loadMediaIfNeeded();
        el.classList.add('pressed');
        try{ audio.currentTime=0; audio.play(); }catch{}
        pulse(el,audio);
      });
      el.addEventListener('pointerup',()=>el.classList.remove('pressed'));
      el.addEventListener('pointerleave',()=>el.classList.remove('pressed'));
      audio.addEventListener('ended',()=>{ el.classList.remove('pressed'); el.style.transform=''; });
    }
    addSoundEvents(dog,pipiAudio);
    addSoundEvents(jpHead,jpAudio);

    // ---------- Remote update hook ----------
    window.TotoTypeUI = window.TotoTypeUI || {};
    window.TotoTypeUI.onRemoteTextApplied = (remoteText) => {
      const txt = (typeof remoteText === 'string') ? remoteText : editor.innerText;
      if (txt.trim() === '') {
        fontSizeVW = defaultFontVW;
        setFontSize();
      }
      adjustFontSizeToFit();
      refreshState();
    };

    // ---------- Clear helpers ----------
    function clearEditorAndReset(){
      document.execCommand('selectAll');
      document.execCommand('delete');
      fontSizeVW = defaultFontVW;
      setFontSize();
      refreshState();
    }

    async function clearAndPropagate(){
      if (currentMode() === 'viewer') return;
      clearEditorAndReset();
      if (shareSwitch.checked) {
        if (window.FirebasePad?.setText) {
          try { await window.FirebasePad.setText(''); } catch {}
        }
      } else {
        saveSoloText(editor.innerText);
      }
      if (!isMobile) editor.focus();
    }

    // ---------- Settings open/close + disable typing while open ----------
    let settingsOpen = false;

    function setEditorInteractiveWhileSettings(open){
      if (open) {
        editor.blur();
        editor.setAttribute('contenteditable','false');
        editor.style.pointerEvents = 'none';
      } else {
        editor.style.pointerEvents = 'auto';
        applyEditorByMode();
      }
    }

    function openSettings(){
      settingsOpen = true;
      setEditorInteractiveWhileSettings(true);
      settingsMenu.style.display='flex';
      if (isMobile) settingsOverlay.style.display='block';
    }
    function closeSettings(){
      settingsOpen = false;
      settingsMenu.style.display='none';
      settingsOverlay.style.display='none';
      setEditorInteractiveWhileSettings(false);
      if (!isMobile && currentMode() !== 'viewer') editor.focus();
    }

    settingsBtn.addEventListener('click',()=> (settingsMenu.style.display==='flex') ? closeSettings() : openSettings());
    mobileGear.addEventListener('click',()=> (settingsMenu.style.display==='flex') ? closeSettings() : openSettings());
    settingsOverlay.addEventListener('click', closeSettings);
    doneBtn.addEventListener('click', closeSettings);

    document.addEventListener('touchstart', (e)=>{
      if (!settingsOpen) return;
      if (e.target === editor) { e.preventDefault(); e.stopPropagation(); }
    }, {passive:false});

    // ---------- Mode transitions ----------
    let prevMode = 'solo';

    async function toSolo(){
      if (window.FirebasePad?.disable) window.FirebasePad.disable();
      editor.innerText = loadSoloText();
      fontSizeVW = defaultFontVW; setFontSize();
      adjustFontSizeToFit();
      shareSwitch.checked = false;
      viewerSwitch.checked = false;
      applyEditorByMode();
      refreshState();
    }

    async function toShare(fromSolo){
      viewerSwitch.checked = false;
      shareSwitch.checked = true;

      if (fromSolo) {
        saveSoloText(editor.innerText);
        editor.innerText = '';
        fontSizeVW = defaultFontVW; setFontSize();
        refreshState();
      }

      applyEditorByMode();
      if (window.FirebasePad?.enable) await window.FirebasePad.enable({ writable:true });
      if (window.FirebasePad?.setWritable) window.FirebasePad.setWritable(true);
      refreshState();
    }

    async function toViewer(fromSolo){
      shareSwitch.checked = false;
      viewerSwitch.checked = true;

      if (fromSolo) {
        saveSoloText(editor.innerText);
        editor.innerText = '';
        fontSizeVW = defaultFontVW; setFontSize();
        refreshState();
      }

      applyEditorByMode();
      if (window.FirebasePad?.enable) await window.FirebasePad.enable({ writable:false });
      if (window.FirebasePad?.setWritable) window.FirebasePad.setWritable(false);
      refreshState();
    }

    async function handleModeChange(){
      const mode = currentMode();
      if (mode === prevMode) { applyEditorByMode(); refreshState(); return; }

      if (mode === 'solo') {
        await toSolo();
      } else if (mode === 'share') {
        if (prevMode === 'solo') await toShare(true);
        else {
          applyEditorByMode();
          if (window.FirebasePad?.enable) await window.FirebasePad.enable({ writable:true });
          if (window.FirebasePad?.setWritable) window.FirebasePad.setWritable(true);
          refreshState();
        }
      } else if (mode === 'viewer') {
        if (prevMode === 'solo') await toViewer(true);
        else {
          applyEditorByMode();
          if (window.FirebasePad?.enable) await window.FirebasePad.enable({ writable:false });
          if (window.FirebasePad?.setWritable) window.FirebasePad.setWritable(false);
          refreshState();
        }
      }

      prevMode = mode;
      if (isMobile || mode === 'viewer') editor.blur();
    }

    // Share / Viewer mutually exclusive
    shareSwitch.addEventListener('change', async ()=>{
      if (shareSwitch.checked) viewerSwitch.checked = false;
      await handleModeChange();
    });
    viewerSwitch.addEventListener('change', async ()=>{
      if (viewerSwitch.checked) shareSwitch.checked = false;
      await handleModeChange();
    });

    // ---------- Toggles ----------
    darkSwitch.addEventListener('change',()=>{
      darkSwitch.checked ? body.classList.add('dark-mode') : body.classList.remove('dark-mode');
      refreshState();
    });

    imagesSwitch.addEventListener('change',()=> toggleImages(imagesSwitch.checked));

    // ---------- Input handling ----------
    editor.addEventListener('input',()=>{
      if (currentMode() === 'viewer') return;
      if (!shareSwitch.checked) saveSoloText(editor.innerText);
      adjustFontSizeToFit();
      refreshState();
    });

    // Desktop keyboard shortcuts
    document.addEventListener('keydown',e=>{
      if (isMobile) return;
      if (currentMode() === 'viewer') return;

      if(e.ctrlKey && e.key==='Backspace'){
        e.preventDefault();
        clearAndPropagate();
        return;
      }
      if(e.ctrlKey && (e.key==='+' || e.key==='=')){
        e.preventDefault();
        fontSizeVW = Math.min(fontSizeVW+1,20);
        setFontSize();
      }
      if(e.ctrlKey && e.key==='-'){
        e.preventDefault();
        fontSizeVW = Math.max(fontSizeVW-1,2);
        setFontSize();
      }
    });

    // Desktop zoom buttons
    if (zoomInBtn && zoomOutBtn){
      zoomInBtn.addEventListener('click',()=>{ fontSizeVW=Math.min(fontSizeVW+1,20); setFontSize(); if(currentMode()!=='viewer') editor.focus(); });
      zoomOutBtn.addEventListener('click',()=>{ fontSizeVW=Math.max(fontSizeVW-1,2); setFontSize(); if(currentMode()!=='viewer') editor.focus(); });
    }

    // Mobile clear button
    mobileClear.addEventListener('click', clearAndPropagate);

    // ---------- init ----------
    window.onload=()=>{
      shareSwitch.checked = false;
      viewerSwitch.checked = false;
      prevMode = 'solo';

      defaultFontVW = isMobile ? DEFAULT_FONT_VW_MOBILE : DEFAULT_FONT_VW_DESKTOP;
      fontSizeVW = defaultFontVW;
      setFontSize();

      if (isMobile) {
        imagesSwitch.checked = false;
        toggleImages(false);
      } else {
        imagesSwitch.checked = true;
        toggleImages(true);
      }

      editor.innerText = loadSoloText();
      adjustFontSizeToFit();
      applyEditorByMode();

      // ensure bg matches toggle state
      if (darkSwitch.checked) body.classList.add('dark-mode');
      else body.classList.remove('dark-mode');

      refreshState();

      if (isMobile) editor.blur();
      else editor.focus();
    };
  </script>

  <!-- Firebase sync is ONLY loaded/used when Share/Viewer is enabled -->
  <script type="module">
    const FIREBASE_APP_URL = "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
    const FIREBASE_DB_URL  = "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB24IJIcEFqXpeiZiUPwLxRg51rbwObuAo",
      authDomain: "tototype-8e5bf.firebaseapp.com",
      projectId: "tototype-8e5bf",
      storageBucket: "tototype-8e5bf.firebasestorage.app",
      messagingSenderId: "905146064272",
      appId: "1:905146064272:web:c329feeabfdb6eeefba715",
      databaseURL: "https://tototype-8e5bf-default-rtdb.firebaseio.com/"
    };

    let app=null, db=null, padRef=null;
    let unsub=null;
    let applyingRemote=false;
    let writeTimer=null;
    let inputHandler=null;
    let writable=false;

    async function ensureFirebase(){
      if (app && db && padRef) return;
      const { initializeApp } = await import(FIREBASE_APP_URL);
      const { getDatabase, ref, set, onValue } = await import(FIREBASE_DB_URL);

      app = initializeApp(firebaseConfig);
      db = getDatabase(app);
      padRef = ref(db, "sharedPad/text");

      window.__fb_set = set;
      window.__fb_onValue = onValue;
    }

    function attachWriter(){
      const editorEl = document.getElementById("editor");
      const { set } = window.__fb_set ? { set: window.__fb_set } : {};
      if (inputHandler) return;

      inputHandler = () => {
        if (!writable) return;
        if (applyingRemote) return;
        clearTimeout(writeTimer);
        const text = editorEl.innerText;
        writeTimer = setTimeout(async () => {
          try { await set(padRef, text); } catch (e) { console.error(e); }
        }, 80);
      };
      editorEl.addEventListener("input", inputHandler);
    }

    function detachWriter(){
      const editorEl = document.getElementById("editor");
      if (inputHandler) editorEl.removeEventListener("input", inputHandler);
      inputHandler = null;
      if (writeTimer) clearTimeout(writeTimer);
      writeTimer = null;
    }

    function getCaretOffset(el){
      const sel = window.getSelection?.();
      if (!sel || sel.rangeCount === 0) return null;
      const range = sel.getRangeAt(0);
      if (!el.contains(range.startContainer)) return null;
      const pre = document.createRange();
      pre.selectNodeContents(el);
      pre.setEnd(range.startContainer, range.startOffset);
      return pre.toString().length;
    }

    function setCaretOffset(el, offset){
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
      let node, count = 0;
      while ((node = walker.nextNode())) {
        const next = count + node.nodeValue.length;
        if (offset <= next) {
          const range = document.createRange();
          range.setStart(node, Math.max(0, offset - count));
          range.collapse(true);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
          return;
        }
        count = next;
      }
      try { el.focus(); } catch {}
    }

    async function setText(text){
      await ensureFirebase();
      const { set } = window.__fb_set ? { set: window.__fb_set } : {};
      try { await set(padRef, text ?? ""); } catch (e) { console.error(e); }
    }

    async function enable(opts={writable:true}){
      await ensureFirebase();
      writable = !!opts.writable;

      const editorEl = document.getElementById("editor");
      const { onValue } = window.__fb_onValue ? { onValue: window.__fb_onValue } : {};
      if (!unsub) {
        unsub = onValue(padRef, (snap) => {
          const remoteText = snap.val() ?? "";
          const current = editorEl.innerText;

          if (remoteText === current) {
            if ((remoteText ?? "").trim() === "") {
              try { window.TotoTypeUI?.onRemoteTextApplied?.(remoteText); } catch {}
            }
            return;
          }

          const focused = (document.activeElement === editorEl);
          const caret = focused ? getCaretOffset(editorEl) : null;

          applyingRemote = true;
          editorEl.innerText = remoteText;
          applyingRemote = false;

          try { window.TotoTypeUI?.onRemoteTextApplied?.(remoteText); } catch {}

          if (focused && caret !== null) {
            try { setCaretOffset(editorEl, Math.min(caret, editorEl.innerText.length)); } catch {}
          }
        });
      }

      if (writable) attachWriter();
      else detachWriter();
    }

    function setWritable(w){
      writable = !!w;
      if (writable) attachWriter();
      else detachWriter();
    }

    function disable(){
      detachWriter();
      if (unsub) { try { unsub(); } catch {} }
      unsub = null;
      applyingRemote=false;
    }

    function isEnabled(){ return !!unsub; }

    window.FirebasePad = {
      enable,
      disable,
      setText,
      setWritable,
      isEnabled
    };
  </script>
</body>
</html>

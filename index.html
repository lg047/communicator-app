<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- ✅ critical for iPhone/iPad sizing + media queries -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- ✅ PWA / iOS "Add to Home Screen" -->
  <link rel="manifest" href="manifest.webmanifest" />
  <meta name="theme-color" content="#ffffff" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="TotoType" />
  <link rel="apple-touch-icon" href="app_icon_1024.png" />
  <link rel="icon" href="app_icon_1024.png" type="image/png" sizes="1024x1024" />

  <meta property="og:title" content="TotoType" />
  <meta property="og:description" content="A simple speech interface for fast communication." />
  <meta property="og:image" content="https://postimg.cc/F1sD5n4P" />
  <meta property="og:url" content="https://tototype.com" />
  <meta property="og:type" content="website" />
  <link rel="icon" href="/tototype_icon_new.png" type="image/png" />
  <title>TotoType</title>

  <style>
    html,body{margin:0;padding:0;width:100%;height:100%;overflow:hidden;background:#fff;font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;transition:background-color .3s,color .3s}

    /* ✅ Only selectable thing should be typed text */
    body, body * { -webkit-user-select:none; user-select:none; }
    #editor, #editor * { -webkit-user-select:text; user-select:text; }

    body.dark-mode{color:#fff;background:#000}
    body.dark-mode #editor{color:#fff}

    /* prevent any background gaps */
    html { background:#fff; }
    html.dark-mode { background:#000; }
    html.settings-open, body.settings-open { background: rgba(0,0,0,.45) !important; }

    #editor{
      width:100%;
      height:calc(100% - 80px);
      font-size:6vw;
      line-height:1.2;
      white-space:pre-wrap;
      overflow-wrap:break-word;
      word-break:break-word;
      outline:none;
      padding:90px 200px;
      box-sizing:border-box;
      color:inherit
    }

    /* Desktop buttons */
    #settingsBtn, #ringBtn{
      position:fixed;top:20px;
      background:none;border:none;
      font-size:4rem;cursor:pointer;color:#888;
      z-index:1003;
      padding:0;
      line-height:1;
    }
    #settingsBtn{right:20px}
    #ringBtn{left:20px}

    .iconBtn svg{
      width:3.2rem;height:3.2rem;
      stroke:currentColor;
      fill:none;
      stroke-width:2.2;
      stroke-linecap:round;
      stroke-linejoin:round;
      vertical-align:middle;
    }

    /* Mobile fixed buttons (ring on left; clear+gear on right) */
    #mobileTopRight{
      position:fixed;
      top:12px;
      right:12px;
      display:none;
      gap:10px;
      z-index:1004;
      align-items:center;
    }
    #mobileRingWrap{
      position:fixed;
      top:12px;
      left:12px;
      display:none;
      z-index:1004;
      align-items:center;
    }

    .topBtn{
      border:none;
      background:rgba(255,255,255,.92);
      box-shadow:0 10px 22px rgba(0,0,0,.22);
      cursor:pointer;
      color:#111;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation; /* ✅ helps iOS click synthesis */
    }
    body.dark-mode .topBtn{
      background:rgba(0,0,0,.75);
      color:#fff;
    }

    #settingsOverlay{
      position:fixed;inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      z-index:1001
    }

    #settingsMenu{
      position:fixed;top:80px;right:20px;
      background:rgba(255,255,255,.95);
      border:1px solid #ccc;border-radius:8px;
      display:none;flex-direction:column;
      padding:12px;
      box-shadow:0 2px 8px rgba(0,0,0,.18);
      z-index:1002;width:280px
    }
    body.dark-mode #settingsMenu{background:rgba(0,0,0,.9);border-color:#444}

    .settings-item{display:flex;justify-content:space-between;align-items:center;margin:10px 0}
    .switch{position:relative;display:inline-block;width:50px;height:24px}
    .switch input{opacity:0;width:0;height:0}
    .slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#ccc;transition:.2s;border-radius:24px}
    .slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:#fff;transition:.2s;border-radius:50%}
    input:checked + .slider{background:#2196f3}
    input:checked + .slider:before{transform:translateX(26px)}
    .switch-label{font-size:.95rem;color:inherit}

    #doneBtn{
      margin-top:10px;width:100%;
      padding:8px;font-size:1rem;
      background:none;border:1px solid #888;border-radius:10px;
      cursor:pointer;color:inherit;
      touch-action: manipulation;
    }

    /* ---------- Desktop footer: centered mode + zoom ---------- */
    #footerBar{
      position:fixed;
      left:50%;
      bottom:12px;
      transform:translateX(-50%);
      display:flex;
      align-items:center;
      gap:14px;
      padding:8px 12px;
      border-radius:10px;
      background:rgba(255,255,255,.65);
      color:#333;
      z-index:1000;
      pointer-events:none;
    }
    body.dark-mode #footerBar{
      background:rgba(0,0,0,.6);
      color:#ddd;
    }
    #modeLabel{
      font-size:.95rem;
      pointer-events:none;
      white-space:nowrap;
    }
    #zoomGroup{
      display:flex;
      gap:8px;
      pointer-events:auto;
    }
    #zoomGroup button{
      font-size:1.1rem;
      padding:.38em .75em;
      border:none;
      border-radius:8px;
      background:rgba(210,210,210,.95);
      cursor:pointer;
      color:#222;
    }
    body.dark-mode #zoomGroup button{
      background:rgba(55,55,55,.85);
      color:#eee;
    }

    #controls, #shortcuts { display:none; }

    #dog,#jpHead{position:fixed;bottom:0;height:240px;pointer-events:auto;cursor:pointer;transition:transform .05s linear,filter .1s}
    #jpHead{right:0;height:225px}
    #dog.pressed,#jpHead.pressed{filter:brightness(.8)}

    @media (max-width: 900px), (pointer: coarse) {
      #settingsBtn, #ringBtn{display:none;}

      #mobileTopRight{
        display:flex;
        top:calc(14px + env(safe-area-inset-top));
        right:14px;
        gap:16px;
        justify-content:flex-end;
      }
      #mobileRingWrap{
        display:flex;
        top:calc(14px + env(safe-area-inset-top));
        left:14px;
      }

      #mobileRing, #mobileGear{
        width:auto;
        padding:12px 14px;
        font-size:2.2rem;
        border-radius:999px;
      }

      #mobileClear{
        width:auto;
        padding:14px 18px;
        font-size:2.0rem;
        border-radius:22px;
      }

      #footerBar{display:none !important;}

      #editor{
        padding:140px 22px;
        height:100%;
      }

      body.pwa-standalone #editor{
        padding-top:165px;
      }

      #settingsMenu{
        left:16px;
        right:16px;
        top:50%;
        transform:translateY(-50%);
        width:auto;
        max-height:55vh;
        overflow:auto;
        border-radius:22px;
        padding:10px 10px 10px;
        box-shadow:0 16px 48px rgba(0,0,0,.32);
      }

      #imagesItem{display:none !important;}

      .settings-item{margin:0;padding:10px 4px;}
      .switch-label{font-size:1.65rem;line-height:1.15;}
      .switch{width:110px;height:56px}
      .slider{border-radius:56px}
      .slider:before{width:48px;height:48px;left:4px;bottom:4px;}
      input:checked + .slider:before{transform:translateX(50px)}
      #doneBtn{margin-top:12px;font-size:1.65rem;padding:12px 12px;border-radius:18px;border-width:2px;}

      #mobileRing svg{width:2.2rem;height:2.2rem;stroke:currentColor}
    }
  </style>
</head>

<body>
  <!-- Desktop corner buttons -->
  <button id="ringBtn" class="iconBtn" aria-label="Ring">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M18 8a6 6 0 10-12 0c0 7-3 7-3 7h18s-3 0-3-7"/>
      <path d="M13.73 21a2 2 0 01-3.46 0"/>
    </svg>
  </button>
  <button id="settingsBtn" aria-label="Settings">⚙</button>

  <!-- Mobile buttons -->
  <div id="mobileRingWrap">
    <button class="topBtn" id="mobileRing" aria-label="Ring">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M18 8a6 6 0 10-12 0c0 7-3 7-3 7h18s-3 0-3-7"/>
        <path d="M13.73 21a2 2 0 01-3.46 0"/>
      </svg>
    </button>
  </div>
  <div id="mobileTopRight">
    <button class="topBtn" id="mobileClear">Clear</button>
    <button class="topBtn" id="mobileGear" aria-label="Settings">⚙</button>
  </div>

  <div id="settingsOverlay"></div>

  <div id="settingsMenu" aria-modal="true" role="dialog">
    <div class="settings-item" id="darkItem">
      <span class="switch-label">Dark Mode</span>
      <label class="switch"><input type="checkbox" id="darkSwitch"><span class="slider"></span></label>
    </div>

    <div class="settings-item" id="muteItem">
      <span class="switch-label">Mute Ring</span>
      <label class="switch"><input type="checkbox" id="muteSwitch"><span class="slider"></span></label>
    </div>

    <div class="settings-item" id="shareItem">
      <span class="switch-label">Share Mode</span>
      <label class="switch"><input type="checkbox" id="shareSwitch"><span class="slider"></span></label>
    </div>

    <div class="settings-item" id="viewerItem">
      <span class="switch-label">Viewer Mode</span>
      <label class="switch"><input type="checkbox" id="viewerSwitch"><span class="slider"></span></label>
    </div>

    <div class="settings-item" id="imagesItem">
      <span class="switch-label">Show Images</span>
      <label class="switch"><input type="checkbox" id="imagesSwitch" checked><span class="slider"></span></label>
    </div>

    <button id="doneBtn">Done</button>
  </div>

  <div id="editor" contenteditable="true" spellcheck="false"></div>

  <!-- Desktop footer -->
  <div id="footerBar">
    <div id="modeLabel">Mode: Solo</div>
    <div id="zoomGroup">
      <button id="zoomOut" aria-label="Zoom out">A-</button>
      <button id="zoomIn" aria-label="Zoom in">A+</button>
    </div>
  </div>

  <!-- Media -->
  <img data-src="pipi_new1.png" loading="lazy" decoding="async" id="dog" alt="pipi image" style="display:none">
  <img data-src="jp.png" loading="lazy" decoding="async" id="jpHead" alt="jp image" style="display:none">
  <audio id="pipiSound" data-src="pipi.wav" preload="none"></audio>
  <audio id="jpSound" data-src="jp.wav" preload="none"></audio>

  <!-- Ring audio -->
  <audio id="chimeSound" src="chime.wav" preload="none"></audio>

  <script>
    // ✅ Register service worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(()=>{});
      });
    }

    // ✅ Detect standalone PWA and mark body (for styling & behavior)
    const isStandalone = (() => {
      try {
        return (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || (window.navigator && window.navigator.standalone === true);
      } catch { return false; }
    })();
    if (isStandalone) document.body.classList.add('pwa-standalone');

    // ✅ Disable pinch zoom ONLY in PWA standalone
    // FIX: remove global touchend preventDefault (it was killing Clear clicks after focus/blur on iOS).
    // We only block true multi-touch gestures.
    if (isStandalone) {
      const prevent = (e) => { e.preventDefault(); };
      document.addEventListener('gesturestart', prevent, { passive:false });
      document.addEventListener('gesturechange', prevent, { passive:false });
      document.addEventListener('gestureend', prevent, { passive:false });

      document.addEventListener('touchmove', (e) => {
        if (e.touches && e.touches.length > 1) e.preventDefault();
      }, { passive:false });

      // ✅ remove double-tap zoom preventer that breaks click synthesis:
      // (intentionally not included)
    }

    const body=document.body;
    const html=document.documentElement;
    const editor=document.getElementById('editor');

    const ringBtn=document.getElementById('ringBtn');
    const settingsBtn=document.getElementById('settingsBtn');

    const mobileRing=document.getElementById('mobileRing');
    const mobileGear=document.getElementById('mobileGear');
    const mobileClear=document.getElementById('mobileClear');

    const settingsMenu=document.getElementById('settingsMenu');
    const settingsOverlay=document.getElementById('settingsOverlay');
    const doneBtn=document.getElementById('doneBtn');

    const darkSwitch=document.getElementById('darkSwitch');
    const muteSwitch=document.getElementById('muteSwitch');
    const imagesSwitch=document.getElementById('imagesSwitch');
    const shareSwitch=document.getElementById('shareSwitch');
    const viewerSwitch=document.getElementById('viewerSwitch');

    const zoomInBtn=document.getElementById('zoomIn');
    const zoomOutBtn=document.getElementById('zoomOut');
    const modeLabel=document.getElementById('modeLabel');

    const dog=document.getElementById('dog');
    const jpHead=document.getElementById('jpHead');
    const pipiAudio=document.getElementById('pipiSound');
    const jpAudio=document.getElementById('jpSound');

    const chimeAudio=document.getElementById('chimeSound');

    // ---------- Mobile/tablet detection ----------
    const isMobile = (() => {
      const coarse = !!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
      const touchPoints = navigator.maxTouchPoints || 0;
      const isIPadLike = (navigator.platform === 'MacIntel' && touchPoints > 1);
      const ua = navigator.userAgent || '';
      const uaMobile = /iPhone|iPad|iPod|Android/i.test(ua);
      return uaMobile || isIPadLike || (coarse && touchPoints > 0);
    })();

    // ---------- Keys ----------
    const CLIENT_ID_KEY = 'tototype_client_id';
    const MUTE_KEY = 'tototype_mute_ring';
    const SOLO_KEY = 'tototype_solo_text';
    const LAST_RING_SEEN_KEY = 'tototype_last_ring_seen';

    function makeId(len=10){
      const chars='abcdefghijklmnopqrstuvwxyz0123456789';
      let s='';
      const arr=new Uint8Array(len);
      crypto.getRandomValues(arr);
      for(let i=0;i<len;i++) s+=chars[arr[i]%chars.length];
      return s;
    }

    let clientId = localStorage.getItem(CLIENT_ID_KEY);
    if (!clientId) {
      clientId = makeId(12);
      localStorage.setItem(CLIENT_ID_KEY, clientId);
    }

    function loadSoloText(){ return localStorage.getItem(SOLO_KEY) ?? ''; }
    function saveSoloText(t){ localStorage.setItem(SOLO_KEY, t ?? ''); }

    function isMuted(){ return localStorage.getItem(MUTE_KEY) === '1'; }
    function setMuted(v){
      localStorage.setItem(MUTE_KEY, v ? '1' : '0');
      muteSwitch.checked = v;
    }

    // ---------- UI state ----------
    const DEFAULT_FONT_VW_DESKTOP = 6;
    const DEFAULT_FONT_VW_MOBILE  = 10;
    let defaultFontVW = isMobile ? DEFAULT_FONT_VW_MOBILE : DEFAULT_FONT_VW_DESKTOP;
    let fontSizeVW = defaultFontVW;

    function setFontSize(){ editor.style.fontSize = fontSizeVW+'vw'; }
    function adjustFontSizeToFit(){
      while(editor.scrollHeight > editor.clientHeight && fontSizeVW > 2){
        fontSizeVW = Math.max(fontSizeVW - 0.5, 2);
        setFontSize();
      }
    }

    function currentMode(){
      if (viewerSwitch.checked) return 'viewer';
      if (shareSwitch.checked) return 'share';
      return 'solo';
    }

    function refreshModeLabel(){
      const mode = currentMode();
      modeLabel.textContent = `Mode: ${mode[0].toUpperCase()+mode.slice(1)}`;
    }

    function updateBg(){
      const bg = darkSwitch.checked ? '#000' : '#fff';
      body.style.backgroundColor = bg;
      html.style.backgroundColor = bg;
      if (darkSwitch.checked) html.classList.add('dark-mode'); else html.classList.remove('dark-mode');
    }

    function refreshState(){
      editor.style.color = darkSwitch.checked ? '#fff' : '';
      updateBg();
      refreshModeLabel();
    }

    function applyEditorByMode(){
      const mode = currentMode();

      if (mode === 'viewer') {
        editor.blur();
        editor.setAttribute('contenteditable','false');
        editor.style.pointerEvents = 'auto';
      } else {
        editor.setAttribute('contenteditable','true');
        editor.style.pointerEvents = 'auto';
      }

      if (mobileClear) mobileClear.style.display = (mode === 'viewer') ? 'none' : '';

      const ringDisplay = (mode === 'viewer') ? 'none' : '';
      ringBtn.style.display = ringDisplay;
      if (mobileRing && mobileRing.parentElement) mobileRing.parentElement.style.display = ringDisplay;
    }

    // ---------- Media lazy-load ----------
    let mediaLoaded = false;
    function loadMediaIfNeeded(){
      if (mediaLoaded) return;
      mediaLoaded = true;

      if (dog && !dog.getAttribute('src')) dog.setAttribute('src', dog.dataset.src || '');
      if (jpHead && !jpHead.getAttribute('src')) jpHead.setAttribute('src', jpHead.dataset.src || '');

      if (pipiAudio && !pipiAudio.getAttribute('src')) pipiAudio.setAttribute('src', pipiAudio.dataset.src || '');
      if (jpAudio && !jpAudio.getAttribute('src')) jpAudio.setAttribute('src', jpAudio.dataset.src || '');
    }

    function toggleImages(show){
      if (isMobile) {
        dog.style.display = 'none';
        jpHead.style.display = 'none';
        [pipiAudio, jpAudio].forEach(a=>{ try{a.pause();a.currentTime=0;}catch{} });
        dog.style.transform = jpHead.style.transform = '';
        return;
      }

      if (show) loadMediaIfNeeded();

      const disp = show ? '' : 'none';
      dog.style.display = jpHead.style.display = disp;

      if(!show){
        [pipiAudio,jpAudio].forEach(a=>{ try{a.pause();a.currentTime=0;}catch{} });
        dog.style.transform = jpHead.style.transform = '';
      }
    }

    // ---------- Ring ----------
    let chimeUnlocked = false;
    let lastSentRingId = null;

    async function unlockChime(){
      if (chimeUnlocked) return;
      try{
        chimeAudio.volume = 0;
        await chimeAudio.play();
        chimeAudio.pause();
        chimeAudio.currentTime = 0;
        chimeAudio.volume = 1;
        chimeUnlocked = true;
      }catch{}
    }

    async function playChime(){
      if (isMuted()) return;
      await unlockChime();
      try{
        chimeAudio.currentTime = 0;
        await chimeAudio.play();
      }catch{}
    }

    function getLastRingSeen(){ return localStorage.getItem(LAST_RING_SEEN_KEY) || ''; }
    function setLastRingSeen(id){ localStorage.setItem(LAST_RING_SEEN_KEY, id || ''); }

    window.TotoTypeUI = window.TotoTypeUI || {};
    window.TotoTypeUI.onRingEvent = async (ev) => {
      if (!ev || !ev.id) return;

      const lastSeen = getLastRingSeen();
      if (ev.id === lastSeen) return;

      setLastRingSeen(ev.id);

      if (ev.sender === clientId && lastSentRingId && ev.id === lastSentRingId) return;

      await playChime();
    };

    window.TotoTypeUI.onRemoteTextApplied = (remoteText) => {
      const txt = (typeof remoteText === 'string') ? remoteText : editor.innerText;
      if (txt.trim() === '') {
        fontSizeVW = defaultFontVW;
        setFontSize();
      }
      adjustFontSizeToFit();
      refreshState();
    };

    // ---------- Clear ----------
    function clearEditorAndReset(){
      document.execCommand('selectAll');
      document.execCommand('delete');
      fontSizeVW = defaultFontVW;
      setFontSize();
      refreshState();
    }

    async function clearAndPropagate(){
      if (currentMode() === 'viewer') return;
      clearEditorAndReset();
      if (shareSwitch.checked) {
        if (window.FirebasePad?.setText) {
          try { await window.FirebasePad.setText(''); } catch (e) { console.error(e); }
        }
      } else {
        saveSoloText(editor.innerText);
      }
      if (!isMobile) editor.focus();
    }

    // ✅ FIX: bind Clear on pointerdown (avoids iOS click synthesis glitch after focus/blur)
    // Works alongside click; pointerdown fires reliably even if click is suppressed.
    function bindFastTap(el, fn){
      if (!el) return;
      el.addEventListener('pointerdown', (e) => {
        // only primary touch/pen/mouse
        if (e.pointerType === 'touch' || e.pointerType === 'pen' || e.pointerType === 'mouse') {
          e.preventDefault();
          e.stopPropagation();
          fn();
        }
      });
      el.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        fn();
      });
    }
    bindFastTap(mobileClear, clearAndPropagate);

    // ---------- Settings open/close ----------
    let settingsOpen = false;

    function setEditorInteractiveWhileSettings(open){
      if (open) {
        editor.blur();
        editor.setAttribute('contenteditable','false');
        editor.style.pointerEvents = 'none';
      } else {
        editor.style.pointerEvents = 'auto';
        applyEditorByMode();
      }
    }

    function openSettings(){
      settingsOpen = true;
      setEditorInteractiveWhileSettings(true);
      settingsMenu.style.display='flex';
      if (isMobile) settingsOverlay.style.display='block';
      body.classList.add('settings-open');
      html.classList.add('settings-open');
    }
    function closeSettings(){
      settingsOpen = false;
      settingsMenu.style.display='none';
      settingsOverlay.style.display='none';
      setEditorInteractiveWhileSettings(false);
      body.classList.remove('settings-open');
      html.classList.remove('settings-open');
      refreshState();
      if (!isMobile && currentMode() !== 'viewer') editor.focus();
    }

    settingsBtn.addEventListener('click',()=> (settingsMenu.style.display==='flex') ? closeSettings() : openSettings());
    mobileGear.addEventListener('click',()=> (settingsMenu.style.display==='flex') ? closeSettings() : openSettings());
    settingsOverlay.addEventListener('click', closeSettings);
    doneBtn.addEventListener('click', closeSettings);

    document.addEventListener('touchstart', (e)=>{
      if (!settingsOpen) return;
      if (e.target === editor) { e.preventDefault(); e.stopPropagation(); }
    }, {passive:false});

    // ---------- Mode transitions ----------
    let prevMode = 'solo';

    async function toSolo(){
      if (window.FirebasePad?.disable) window.FirebasePad.disable();
      editor.innerText = loadSoloText();
      fontSizeVW = defaultFontVW; setFontSize();
      adjustFontSizeToFit();
      shareSwitch.checked = false;
      viewerSwitch.checked = false;
      applyEditorByMode();
      refreshState();
    }

    async function toShare(fromSolo){
      viewerSwitch.checked = false;
      shareSwitch.checked = true;

      if (fromSolo) {
        saveSoloText(editor.innerText);
        editor.innerText = '';
        fontSizeVW = defaultFontVW; setFontSize();
        refreshState();
      }

      applyEditorByMode();
      if (window.FirebasePad?.enable) await window.FirebasePad.enable({ writable:true });
      if (window.FirebasePad?.setWritable) window.FirebasePad.setWritable(true);
      await unlockChime();
      refreshState();
    }

    async function toViewer(fromSolo){
      shareSwitch.checked = false;
      viewerSwitch.checked = true;

      if (fromSolo) {
        saveSoloText(editor.innerText);
        editor.innerText = '';
        fontSizeVW = defaultFontVW; setFontSize();
        refreshState();
      }

      applyEditorByMode();
      if (window.FirebasePad?.enable) await window.FirebasePad.enable({ writable:false });
      if (window.FirebasePad?.setWritable) window.FirebasePad.setWritable(false);
      await unlockChime();
      refreshState();
    }

    async function handleModeChange(){
      const mode = currentMode();
      if (mode === prevMode) { applyEditorByMode(); refreshState(); return; }

      if (mode === 'solo') {
        await toSolo();
      } else if (mode === 'share') {
        if (prevMode === 'solo') await toShare(true);
        else {
          applyEditorByMode();
          if (window.FirebasePad?.enable) await window.FirebasePad.enable({ writable:true });
          if (window.FirebasePad?.setWritable) window.FirebasePad.setWritable(true);
          await unlockChime();
          refreshState();
        }
      } else if (mode === 'viewer') {
        if (prevMode === 'solo') await toViewer(true);
        else {
          applyEditorByMode();
          if (window.FirebasePad?.enable) await window.FirebasePad.enable({ writable:false });
          if (window.FirebasePad?.setWritable) window.FirebasePad.setWritable(false);
          await unlockChime();
          refreshState();
        }
      }

      prevMode = mode;
      if (isMobile || mode === 'viewer') editor.blur();
    }

    shareSwitch.addEventListener('change', async ()=>{
      if (shareSwitch.checked) viewerSwitch.checked = false;
      await handleModeChange();
    });
    viewerSwitch.addEventListener('change', async ()=>{
      if (viewerSwitch.checked) shareSwitch.checked = false;
      await handleModeChange();
    });

    // ---------- Toggles ----------
    darkSwitch.addEventListener('change',()=>{
      darkSwitch.checked ? body.classList.add('dark-mode') : body.classList.remove('dark-mode');
      refreshState();
    });
    muteSwitch.addEventListener('change',()=> setMuted(muteSwitch.checked));
    imagesSwitch.addEventListener('change',()=> toggleImages(imagesSwitch.checked));

    // ---------- Input handling ----------
    editor.addEventListener('input',()=>{
      if (currentMode() === 'viewer') return;
      if (!shareSwitch.checked) saveSoloText(editor.innerText);
      adjustFontSizeToFit();
      refreshState();
    });

    // Zoom buttons
    zoomInBtn.addEventListener('click',()=>{ fontSizeVW=Math.min(fontSizeVW+1,20); setFontSize(); if(currentMode()!=='viewer') editor.focus(); });
    zoomOutBtn.addEventListener('click',()=>{ fontSizeVW=Math.max(fontSizeVW-1,2); setFontSize(); if(currentMode()!=='viewer') editor.focus(); });

    // ---------- Ring button behavior ----------
    async function ringPressed(){
      await unlockChime();
      const mode = currentMode();

      if (mode === 'solo') {
        await playChime();
        return;
      }
      if (mode === 'viewer') return;

      const ringId = makeId(10);
      lastSentRingId = ringId;

      await playChime();

      if (window.FirebasePad?.ring) {
        try {
          await window.FirebasePad.ring({ id: ringId, t: Date.now(), sender: clientId });
          setLastRingSeen(ringId);
        } catch (e) {
          console.error("Ring write failed:", e);
        }
      }
    }

    ringBtn.addEventListener('click', ringPressed);
    mobileRing.addEventListener('click', ringPressed);

    // Unlock attempt on first gesture
    document.addEventListener('pointerdown', () => { unlockChime(); }, { once: true });

    // ---------- init ----------
    window.onload=()=>{
      shareSwitch.checked = false;
      viewerSwitch.checked = false;
      prevMode = 'solo';

      setMuted(isMuted());

      defaultFontVW = isMobile ? DEFAULT_FONT_VW_MOBILE : DEFAULT_FONT_VW_DESKTOP;
      fontSizeVW = defaultFontVW;
      setFontSize();

      if (isMobile) {
        imagesSwitch.checked = false;
        toggleImages(false);
      } else {
        imagesSwitch.checked = true;
        toggleImages(true);
      }

      editor.innerText = loadSoloText();
      adjustFontSizeToFit();

      applyEditorByMode();

      if (darkSwitch.checked) body.classList.add('dark-mode');
      else body.classList.remove('dark-mode');

      refreshState();

      if (isMobile) editor.blur();
      else editor.focus();
    };
  </script>

  <!-- Firebase sync is ONLY loaded/used when Share/Viewer is enabled -->
  <script type="module">
    const FIREBASE_APP_URL = "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
    const FIREBASE_DB_URL  = "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB24IJIcEFqXpeiZiUPwLxRg51rbwObuAo",
      authDomain: "tototype-8e5bf.firebaseapp.com",
      projectId: "tototype-8e5bf",
      storageBucket: "tototype-8e5bf.firebasestorage.app",
      messagingSenderId: "905146064272",
      appId: "1:905146064272:web:c329feeabfdb6eeefba715",
      databaseURL: "https://tototype-8e5bf-default-rtdb.firebaseio.com/"
    };

    let app=null, db=null, textRef=null, ringRef=null;
    let unsubText=null, unsubRing=null;
    let applyingRemote=false;
    let writeTimer=null;
    let inputHandler=null;
    let writable=false;

    async function ensureFirebase(){
      if (app && db && textRef && ringRef) return;
      const { initializeApp } = await import(FIREBASE_APP_URL);
      const { getDatabase, ref, set, onValue } = await import(FIREBASE_DB_URL);

      app = initializeApp(firebaseConfig);
      db = getDatabase(app);
      textRef = ref(db, "sharedPad/text");
      ringRef = ref(db, "sharedPad/ring");

      window.__fb_set = set;
      window.__fb_onValue = onValue;
    }

    function attachWriter(){
      const editorEl = document.getElementById("editor");
      const { set } = window.__fb_set ? { set: window.__fb_set } : {};
      if (inputHandler) return;

      inputHandler = () => {
        if (!writable) return;
        if (applyingRemote) return;
        clearTimeout(writeTimer);
        const text = editorEl.innerText;
        writeTimer = setTimeout(async () => {
          try { await set(textRef, text); } catch (e) { console.error(e); }
        }, 80);
      };
      editorEl.addEventListener("input", inputHandler);
    }

    function detachWriter(){
      const editorEl = document.getElementById("editor");
      if (inputHandler) editorEl.removeEventListener("input", inputHandler);
      inputHandler = null;
      if (writeTimer) clearTimeout(writeTimer);
      writeTimer = null;
    }

    function getCaretOffset(el){
      const sel = window.getSelection?.();
      if (!sel || sel.rangeCount === 0) return null;
      const range = sel.getRangeAt(0);
      if (!el.contains(range.startContainer)) return null;
      const pre = document.createRange();
      pre.selectNodeContents(el);
      pre.setEnd(range.startContainer, range.startOffset);
      return pre.toString().length;
    }

    function setCaretOffset(el, offset){
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
      let node, count = 0;
      while ((node = walker.nextNode())) {
        const next = count + node.nodeValue.length;
        if (offset <= next) {
          const range = document.createRange();
          range.setStart(node, Math.max(0, offset - count));
          range.collapse(true);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
          return;
        }
        count = next;
      }
      try { el.focus(); } catch {}
    }

    async function setText(text){
      await ensureFirebase();
      const { set } = window.__fb_set ? { set: window.__fb_set } : {};
      try { await set(textRef, text ?? ""); } catch (e) { console.error(e); }
    }

    async function ring(ev){
      await ensureFirebase();
      const { set } = window.__fb_set ? { set: window.__fb_set } : {};
      try { await set(ringRef, ev); } catch (e) { console.error("RTDB ring write error:", e); throw e; }
    }

    async function enable(opts={writable:true}){
      await ensureFirebase();
      writable = !!opts.writable;

      const editorEl = document.getElementById("editor");
      const { onValue } = window.__fb_onValue ? { onValue: window.__fb_onValue } : {};

      if (!unsubText) {
        unsubText = onValue(textRef, (snap) => {
          const remoteText = snap.val() ?? "";
          const current = editorEl.innerText;

          if (remoteText === current) {
            if ((remoteText ?? "").trim() === "") {
              try { window.TotoTypeUI?.onRemoteTextApplied?.(remoteText); } catch {}
            }
            return;
          }

          const focused = (document.activeElement === editorEl);
          const caret = focused ? getCaretOffset(editorEl) : null;

          applyingRemote = true;
          editorEl.innerText = remoteText;
          applyingRemote = false;

          try { window.TotoTypeUI?.onRemoteTextApplied?.(remoteText); } catch {}

          if (focused && caret !== null) {
            try { setCaretOffset(editorEl, Math.min(caret, editorEl.innerText.length)); } catch {}
          }
        });
      }

      if (!unsubRing) {
        unsubRing = onValue(ringRef, (snap) => {
          const ev = snap.val();
          if (!ev || !ev.id) return;
          try { window.TotoTypeUI?.onRingEvent?.(ev); } catch {}
        });
      }

      if (writable) attachWriter();
      else detachWriter();
    }

    function setWritable(w){
      writable = !!w;
      if (writable) attachWriter();
      else detachWriter();
    }

    function disable(){
      detachWriter();

      if (unsubText) { try { unsubText(); } catch {} }
      if (unsubRing) { try { unsubRing(); } catch {} }
      unsubText = null;
      unsubRing = null;

      applyingRemote=false;
    }

    function isEnabled(){ return !!unsubText; }

    window.FirebasePad = {
      enable,
      disable,
      setText,
      ring,
      setWritable,
      isEnabled
    };
  </script>
</body>
</html>

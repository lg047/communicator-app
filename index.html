<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta property="og:title" content="TotoType" />
  <meta property="og:description" content="A simple speech interface for fast communication." />
  <meta property="og:image" content="https://postimg.cc/F1sD5n4P" />
  <meta property="og:url" content="https://tototype.com" />
  <meta property="og:type" content="website" />
  <link rel="icon" href="/tototype_icon_new.png" type="image/png" />
  <title>TotoType</title>
  <style>
    html,body{margin:0;padding:0;width:100%;height:100%;overflow:hidden;background:#fff;font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;transition:background-color .3s,color .3s}
    body.dark-mode{color:#fff}
    body.dark-mode #editor{color:#fff}

    #editor{
      width:100%;
      height:calc(100% - 80px);
      font-size:6vw;
      line-height:1.2;
      white-space:pre-wrap;
      overflow-wrap:break-word;
      word-break:break-word;
      outline:none;
      padding:90px 200px;
      box-sizing:border-box;
      color:inherit
    }

    /* Top-right desktop gear */
    #settingsBtn{
      position:fixed;top:20px;right:20px;
      background:none;border:none;
      font-size:4rem;cursor:pointer;color:#888;
      z-index:1003
    }

    /* Mobile top bar (Clear + Gear) */
    #mobileTopBar{
      position:fixed;
      top:12px;
      right:12px;
      display:none;
      gap:10px;
      z-index:1004;
      align-items:center;
    }
    .topBtn{
      border:none;
      border-radius:22px;
      padding:20px 26px;
      font-size:1.6rem;
      line-height:1;
      background:rgba(255,255,255,.92);
      box-shadow:0 6px 18px rgba(0,0,0,.18);
      cursor:pointer;
      color:#111;
      -webkit-tap-highlight-color: transparent;
    }

    body.dark-mode .topBtn{
      background:rgba(0,0,0,.75);
      color:#fff;

    #mobileGear{
      padding:20px 22px;
      font-size:1.9rem;
    }


    /* overlay for mobile modal */
    #settingsOverlay{
      position:fixed;inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      z-index:1001
    }

    /* Settings menu (desktop default: small popover) */
    #settingsMenu{
      position:fixed;top:80px;right:20px;
      background:rgba(255,255,255,.95);
      border:1px solid #ccc;border-radius:8px;
      display:none;flex-direction:column;
      padding:12px;
      box-shadow:0 2px 8px rgba(0,0,0,.18);
      z-index:1002;width:240px
    }
    body.dark-mode #settingsMenu{background:rgba(0,0,0,.9);border-color:#444}

    .settings-item{display:flex;justify-content:space-between;align-items:center;margin:10px 0}
    .switch{position:relative;display:inline-block;width:50px;height:24px}
    .switch input{opacity:0;width:0;height:0}
    .slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#ccc;transition:.4s;border-radius:24px}
    .slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:#fff;transition:.4s;border-radius:50%}
    input:checked + .slider{background:#2196f3}
    input:checked + .slider:before{transform:translateX(26px)}
    .switch-label{font-size:.95rem;color:inherit}

    #doneBtn{
      margin-top:10px;width:100%;
      padding:8px;font-size:1rem;
      background:none;border:1px solid #888;border-radius:10px;
      cursor:pointer;color:inherit
    }

    /* Desktop footer controls */
    #controls{
      position:fixed;bottom:10px;right:10px;
      background:rgba(255,255,255,.7);
      padding:5px;border-radius:5px;
      display:flex;gap:5px;z-index:1000
    }
    body.dark-mode #controls{background:rgba(0,0,0,.7)}
    #controls button{
      font-size:1rem;padding:.2em .5em;border:none;border-radius:3px;
      background:none;color:inherit;cursor:pointer
    }
    #shortcuts{
      position:fixed;bottom:10px;left:50%;transform:translateX(-50%);
      background:rgba(255,255,255,.6);
      padding:4px 6px;border-radius:4px;
      font-size:.8rem;color:#333;
      pointer-events:none;z-index:1000
    }
    body.dark-mode #shortcuts{background:rgba(0,0,0,.6);color:#ddd}

    #dog,#jpHead{position:fixed;bottom:0;height:240px;pointer-events:auto;cursor:pointer;transition:transform .05s linear,filter .1s}
    #jpHead{right:0;height:225px}
    #dog.pressed,#jpHead.pressed{filter:brightness(.8)}

    /* ---------- Mobile / iOS UI ---------- */
    @media (max-width: 900px), (pointer: coarse) {
      /* Use a mobile top bar instead of the desktop gear */
      #settingsBtn{display:none;}
      #mobileTopBar{display:flex;}

      /* Remove footer on mobile entirely */
      #controls{display:none !important;}
      #shortcuts{display:none !important;}

      /* Better mobile text area */
      #editor{
        padding:90px 22px; /* leave room for top bar */
        height:100%;
      }

      /* Big modal settings */
      #settingsMenu{
        top:50%;left:50%;right:auto;
        transform:translate(-50%,-50%);
        width:min(92vw,460px);
        border-radius:18px;
        padding:18px 18px 14px;
        box-shadow:0 12px 38px rgba(0,0,0,.28);
      }
      .switch-label{font-size:1.15rem;}
      #doneBtn{padding:12px;font-size:1.1rem;border-radius:14px;}

      /* Hide options you don't want on mobile */
      #cueItem{display:none !important;}
      #imagesItem{display:none !important;}
    }
  </style>
</head>
<body>
  <!-- Mobile top bar -->
  <div id="mobileTopBar">
    <button class="topBtn" id="mobileClear">Clear</button>
    <button class="topBtn" id="mobileGear" aria-label="Settings">⚙</button>
  </div>

  <!-- Desktop gear -->
  <button id="settingsBtn">⚙</button>

  <div id="settingsOverlay"></div>

  <div id="settingsMenu">
    <div class="settings-item" id="darkItem">
      <span class="switch-label">Dark Mode</span>
      <label class="switch"><input type="checkbox" id="darkSwitch"><span class="slider"></span></label>
    </div>

    <div class="settings-item" id="cueItem">
      <span class="switch-label">Cue Mode</span>
      <label class="switch"><input type="checkbox" id="readySwitch"><span class="slider"></span></label>
    </div>

    <div class="settings-item" id="imagesItem">
      <span class="switch-label">Show Images</span>
      <label class="switch"><input type="checkbox" id="imagesSwitch" checked><span class="slider"></span></label>
    </div>

    <div class="settings-item" id="shareItem">
      <span class="switch-label">Share Mode</span>
      <label class="switch"><input type="checkbox" id="shareSwitch"><span class="slider"></span></label>
    </div>

    <button id="doneBtn">Done</button>
  </div>

  <div id="editor" contenteditable="true" spellcheck="false"></div>

  <!-- Desktop footer controls (hidden on mobile via CSS) -->
  <div id="controls"><button id="zoomOut">A-</button><button id="zoomIn">A+</button></div>
  <div id="shortcuts"></div>

  <!-- Media: DO NOT set src attributes here (prevents unwanted loads & fixes .src truthiness bug) -->
  <img data-src="pipi_new1.png" loading="lazy" decoding="async" id="dog" alt="pipi image" style="display:none">
  <img data-src="jp.png" loading="lazy" decoding="async" id="jpHead" alt="jp image" style="display:none">
  <audio id="pipiSound" data-src="pipi.wav" preload="none"></audio>
  <audio id="jpSound" data-src="jp.wav" preload="none"></audio>

  <script>
    // ---------- DOM refs ----------
    const body=document.body;
    const editor=document.getElementById('editor');

    const settingsBtn=document.getElementById('settingsBtn');
    const settingsMenu=document.getElementById('settingsMenu');
    const settingsOverlay=document.getElementById('settingsOverlay');
    const doneBtn=document.getElementById('doneBtn');

    const mobileGear=document.getElementById('mobileGear');
    const mobileClear=document.getElementById('mobileClear');

    const darkSwitch=document.getElementById('darkSwitch');
    const readySwitch=document.getElementById('readySwitch');
    const imagesSwitch=document.getElementById('imagesSwitch');
    const shareSwitch=document.getElementById('shareSwitch');

    const zoomInBtn=document.getElementById('zoomIn');
    const zoomOutBtn=document.getElementById('zoomOut');
    const shortcuts=document.getElementById('shortcuts');

    const dog=document.getElementById('dog');
    const jpHead=document.getElementById('jpHead');
    const pipiAudio=document.getElementById('pipiSound');
    const jpAudio=document.getElementById('jpSound');

    // ---------- Mobile detection ----------
    const isMobile = (() => {
      const ua = navigator.userAgent || '';
      const uaMobile = /iPhone|iPad|iPod|Android/i.test(ua);
      const coarse = !!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
      return uaMobile || (coarse && window.innerWidth <= 900) || window.innerWidth <= 768;
    })();

    // ---------- Local-only storage (Solo mode) ----------
    const SOLO_KEY = 'tototype_solo_text';
    function loadSoloText(){ return localStorage.getItem(SOLO_KEY) ?? ''; }
    function saveSoloText(t){ localStorage.setItem(SOLO_KEY, t ?? ''); }

    // ---------- UI state ----------
    const DEFAULT_FONT_VW_DESKTOP = 6;
    const DEFAULT_FONT_VW_MOBILE  = 10;  // bigger default on iOS/mobile
    let defaultFontVW = isMobile ? DEFAULT_FONT_VW_MOBILE : DEFAULT_FONT_VW_DESKTOP;

    let fontSizeVW = defaultFontVW;

    const RED_BG='#ffecec',GREEN_BG='#ecffec',DARK_RED_BG='#330000',DARK_GREEN_BG='#003300';

    function setFontSize(){ editor.style.fontSize = fontSizeVW+'vw'; }
    function adjustFontSizeToFit(){
      while(editor.scrollHeight > editor.clientHeight && fontSizeVW > 2){
        fontSizeVW = Math.max(fontSizeVW - 0.5, 2);
        setFontSize();
      }
    }

    function updateShortcuts(){
      if (isMobile) { shortcuts.textContent = ''; return; }
      let mode = shareSwitch.checked ? 'Share' : 'Solo';
      let t = `Mode: ${mode} | Enter: New Line | Ctrl+Backspace: Clear | Ctrl+(+)/(-): Zoom`;
      if(readySwitch.checked)t='Ctrl+Enter: Cue | '+t;
      shortcuts.textContent=t;
    }

    function updateBg(){
      if(readySwitch.checked){
        body.style.backgroundColor = darkSwitch.checked ? DARK_RED_BG : RED_BG;
      }else{
        body.style.backgroundColor = darkSwitch.checked ? '#000' : '#fff';
      }
    }

    function refreshState(){
      editor.style.color = darkSwitch.checked ? '#fff' : '';
      updateShortcuts();
      updateBg();
    }

    // ---------- Media lazy-load (desktop only, and only when images ON) ----------
    let mediaLoaded = false;

    function loadMediaIfNeeded(){
      if (mediaLoaded) return;
      mediaLoaded = true;

      // Use getAttribute('src') because element.src becomes truthy even when unset/empty.
      if (dog && !dog.getAttribute('src')) dog.setAttribute('src', dog.dataset.src || '');
      if (jpHead && !jpHead.getAttribute('src')) jpHead.setAttribute('src', jpHead.dataset.src || '');

      if (pipiAudio && !pipiAudio.getAttribute('src')) pipiAudio.setAttribute('src', pipiAudio.dataset.src || '');
      if (jpAudio && !jpAudio.getAttribute('src')) jpAudio.setAttribute('src', jpAudio.dataset.src || '');
    }

    function toggleImages(show){
      // On mobile: skip media entirely (never load, always hidden)
      if (isMobile) {
        dog.style.display = 'none';
        jpHead.style.display = 'none';
        [pipiAudio, jpAudio].forEach(a=>{ try{a.pause();a.currentTime=0;}catch{} });
        dog.style.transform = jpHead.style.transform = '';
        return;
      }

      // Desktop: load media only if needed and showing
      if (show) loadMediaIfNeeded();

      const disp = show ? '' : 'none';
      dog.style.display = jpHead.style.display = disp;

      if(!show){
        [pipiAudio,jpAudio].forEach(a=>{ try{a.pause();a.currentTime=0;}catch{} });
        dog.style.transform = jpHead.style.transform = '';
      }
    }

    // ---------- Soundboard visuals ----------
    const AudioContext=window.AudioContext||window.webkitAudioContext;
    let audioCtx;
    function ensureCtx(){ if(!AudioContext) return null; if(!audioCtx) audioCtx = new AudioContext(); if(audioCtx.state==='suspended') audioCtx.resume(); return audioCtx; }
    function attachAnalyser(el){
      if(el.analyser || !ensureCtx() || !el.getAttribute('src')) return;
      const src = audioCtx.createMediaElementSource(el);
      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 256;
      src.connect(analyser);
      analyser.connect(audioCtx.destination);
      el.analyser = analyser;
    }
    function pulse(el,audio){
      attachAnalyser(audio);
      if(!audio.analyser) return;
      const data=new Uint8Array(audio.analyser.frequencyBinCount);
      function step(){
        if(audio.paused||audio.ended){ el.style.transform=''; return; }
        audio.analyser.getByteFrequencyData(data);
        let sum=0; for(let i=0;i<data.length;i++) sum+=data[i];
        const scale=1+(sum/data.length/255)*0.12;
        el.style.transform=`scale(${scale})`;
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }
    function addSoundEvents(el,audio){
      el.addEventListener('pointerdown',()=>{
        if (isMobile) return;
        if (!imagesSwitch.checked) return;
        loadMediaIfNeeded();
        el.classList.add('pressed');
        try{ audio.currentTime=0; audio.play(); }catch{}
        pulse(el,audio);
      });
      el.addEventListener('pointerup',()=>el.classList.remove('pressed'));
      el.addEventListener('pointerleave',()=>el.classList.remove('pressed'));
      audio.addEventListener('ended',()=>{ el.classList.remove('pressed'); el.style.transform=''; });
    }
    addSoundEvents(dog,pipiAudio);
    addSoundEvents(jpHead,jpAudio);

    // ---------- Remote update hook (auto-fit + reset size on remote clear) ----------
    window.TotoTypeUI = window.TotoTypeUI || {};
    window.TotoTypeUI.onRemoteTextApplied = (remoteText) => {
      const txt = (typeof remoteText === 'string') ? remoteText : editor.innerText;
      if (txt.trim() === '') {
        fontSizeVW = defaultFontVW;
        setFontSize();
      }
      adjustFontSizeToFit();
      refreshState();
    };

    // ---------- Clear helpers ----------
    function clearEditorAndReset(){
      document.execCommand('selectAll');
      document.execCommand('delete');
      fontSizeVW = defaultFontVW;
      setFontSize();
      refreshState();
    }

    async function clearAndPropagate(){
      clearEditorAndReset();
      if (shareSwitch.checked) {
        if (window.FirebasePad?.setText) {
          try { await window.FirebasePad.setText(''); } catch {}
        }
      } else {
        saveSoloText(editor.innerText);
      }
      editor.focus();
    }

    // ---------- Settings open/close ----------
    function openSettings(){
      settingsMenu.style.display='flex';
      if (isMobile) settingsOverlay.style.display='block';
    }
    function closeSettings(){
      settingsMenu.style.display='none';
      settingsOverlay.style.display='none';
    }

    settingsBtn.addEventListener('click',()=>{
      (settingsMenu.style.display==='flex') ? closeSettings() : openSettings();
    });
    mobileGear.addEventListener('click',()=>{
      (settingsMenu.style.display==='flex') ? closeSettings() : openSettings();
    });
    settingsOverlay.addEventListener('click', closeSettings);
    doneBtn.addEventListener('click', closeSettings);

    // ---------- Toggles ----------
    darkSwitch.addEventListener('change',()=>{
      darkSwitch.checked ? body.classList.add('dark-mode') : body.classList.remove('dark-mode');
      refreshState();
    });

    readySwitch.addEventListener('change', refreshState);

    imagesSwitch.addEventListener('change',()=>{
      toggleImages(imagesSwitch.checked);
    });

    // ---------- Share mode ----------
    async function setShareMode(on){
      if (on) {
        saveSoloText(editor.innerText);
        editor.innerText = '';
        fontSizeVW = defaultFontVW; setFontSize();
        refreshState();
        if (window.FirebasePad?.enable) await window.FirebasePad.enable();
      } else {
        if (window.FirebasePad?.disable) window.FirebasePad.disable();
        editor.innerText = loadSoloText();
        fontSizeVW = defaultFontVW; setFontSize();
        adjustFontSizeToFit();
        refreshState();
      }
    }

    shareSwitch.addEventListener('change', async ()=>{
      await setShareMode(shareSwitch.checked);
      editor.focus();
      refreshState();
    });

    // ---------- Input handling ----------
    editor.addEventListener('input',()=>{
      if (!shareSwitch.checked) saveSoloText(editor.innerText);
      adjustFontSizeToFit();
      refreshState();
    });

    // Desktop keyboard shortcuts
    document.addEventListener('keydown',e=>{
      if (isMobile) return;

      if(readySwitch.checked && e.ctrlKey && e.key==='Enter'){
        e.preventDefault();
        body.style.backgroundColor = darkSwitch.checked ? DARK_GREEN_BG : GREEN_BG;
        editor.focus();
      }
      if(e.ctrlKey && e.key==='Backspace'){
        e.preventDefault();
        clearAndPropagate();
        return;
      }
      if(e.ctrlKey && (e.key==='+' || e.key==='=')){
        e.preventDefault();
        fontSizeVW = Math.min(fontSizeVW+1,20);
        setFontSize();
      }
      if(e.ctrlKey && e.key==='-'){
        e.preventDefault();
        fontSizeVW = Math.max(fontSizeVW-1,2);
        setFontSize();
      }
    });

    // Desktop zoom buttons
    if (zoomInBtn && zoomOutBtn){
      zoomInBtn.addEventListener('click',()=>{ fontSizeVW=Math.min(fontSizeVW+1,20); setFontSize(); editor.focus(); });
      zoomOutBtn.addEventListener('click',()=>{ fontSizeVW=Math.max(fontSizeVW-1,2); setFontSize(); editor.focus(); });
    }

    // Mobile clear button (top bar)
    mobileClear.addEventListener('click', clearAndPropagate);

    // ---------- init ----------
    window.onload=()=>{
      editor.focus();

      // default to Solo on load
      shareSwitch.checked = false;

      defaultFontVW = isMobile ? DEFAULT_FONT_VW_MOBILE : DEFAULT_FONT_VW_DESKTOP;
      fontSizeVW = defaultFontVW;
      setFontSize();

      // Desktop: images ON by default. Mobile: skip media entirely.
      if (isMobile) {
        imagesSwitch.checked = false;
        toggleImages(false);
      } else {
        imagesSwitch.checked = true;
        toggleImages(true);
      }

      editor.innerText = loadSoloText();
      adjustFontSizeToFit();
      refreshState();
    };
  </script>

  <!-- Firebase sync is ONLY loaded/used when Share Mode is enabled -->
  <script type="module">
    const FIREBASE_APP_URL = "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
    const FIREBASE_DB_URL  = "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB24IJIcEFqXpeiZiUPwLxRg51rbwObuAo",
      authDomain: "tototype-8e5bf.firebaseapp.com",
      projectId: "tototype-8e5bf",
      storageBucket: "tototype-8e5bf.firebasestorage.app",
      messagingSenderId: "905146064272",
      appId: "1:905146064272:web:c329feeabfdb6eeefba715",
      databaseURL: "https://tototype-8e5bf-default-rtdb.firebaseio.com/"
    };

    let app=null, db=null, padRef=null;
    let unsub=null;
    let applyingRemote=false;
    let writeTimer=null;
    let inputHandler=null;

    async function ensureFirebase(){
      if (app && db && padRef) return;
      const { initializeApp } = await import(FIREBASE_APP_URL);
      const { getDatabase, ref, set, onValue } = await import(FIREBASE_DB_URL);

      app = initializeApp(firebaseConfig);
      db = getDatabase(app);
      padRef = ref(db, "sharedPad/text");

      window.__fb_set = set;
      window.__fb_onValue = onValue;
    }

    function getCaretOffset(el){
      const sel = window.getSelection?.();
      if (!sel || sel.rangeCount === 0) return null;
      const range = sel.getRangeAt(0);
      if (!el.contains(range.startContainer)) return null;
      const pre = document.createRange();
      pre.selectNodeContents(el);
      pre.setEnd(range.startContainer, range.startOffset);
      return pre.toString().length;
    }

    function setCaretOffset(el, offset){
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
      let node, count = 0;
      while ((node = walker.nextNode())) {
        const next = count + node.nodeValue.length;
        if (offset <= next) {
          const range = document.createRange();
          range.setStart(node, Math.max(0, offset - count));
          range.collapse(true);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
          return;
        }
        count = next;
      }
      try { el.focus(); } catch {}
    }

    async function setText(text){
      await ensureFirebase();
      const { set } = window.__fb_set ? { set: window.__fb_set } : {};
      try { await set(padRef, text ?? ""); } catch (e) { console.error(e); }
    }

    async function enable(){
      await ensureFirebase();
      if (unsub) return;

      const editorEl = document.getElementById("editor");
      const { set, onValue } = window.__fb_set ? { set: window.__fb_set, onValue: window.__fb_onValue } : {};

      unsub = onValue(padRef, (snap) => {
        const remoteText = snap.val() ?? "";
        const current = editorEl.innerText;

        if (remoteText === current) {
          if ((remoteText ?? "").trim() === "") {
            try { window.TotoTypeUI?.onRemoteTextApplied?.(remoteText); } catch {}
          }
          return;
        }

        const focused = (document.activeElement === editorEl);
        const caret = focused ? getCaretOffset(editorEl) : null;

        applyingRemote = true;
        editorEl.innerText = remoteText;
        applyingRemote = false;

        try { window.TotoTypeUI?.onRemoteTextApplied?.(remoteText); } catch {}

        if (focused && caret !== null) {
          try { setCaretOffset(editorEl, Math.min(caret, editorEl.innerText.length)); } catch {}
        }
      });

      inputHandler = () => {
        if (applyingRemote) return;
        clearTimeout(writeTimer);
        const text = editorEl.innerText;
        writeTimer = setTimeout(async () => {
          try { await set(padRef, text); } catch (e) { console.error(e); }
        }, 80);
      };
      editorEl.addEventListener("input", inputHandler);
    }

    function disable(){
      const editorEl = document.getElementById("editor");
      if (inputHandler) editorEl.removeEventListener("input", inputHandler);
      inputHandler = null;

      if (unsub) { try { unsub(); } catch {} }
      unsub = null;

      if (writeTimer) clearTimeout(writeTimer);
      writeTimer = null;
    }

    window.FirebasePad = {
      enable,
      disable,
      setText,
      isEnabled: () => !!unsub
    };
  </script>
</body>
</html>
